{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to AREA_DOCUMENTATION This is about the full documentation of AREA project Description The goal of this project is to discover, as a whole, the software platform that you have chosen through the creation of a business application. To do this, AREA is a software suite that functions similar to that of IFTTT and/or Zapier. It is broken into three parts : - An application server to implement all the features listed below (see Features) - A web client to use the application from your browser by querying the application server - A mobile client to use the application from your phone by querying the application server Features The application will offer the following funtionalities: - The user registers on the application in order to obtain an account - The registered user then confirms their enrollment on the application before being able to use it - The application then asks the authenticated user to subscribe to Services - Each service offers the following components: * type Action * type REAction - The authenticated user composes AREA by interconnecting an Action to a REAction previously configured - The application triggers AREA automatically thanks to triggers Home Installation Mobile & Web Interface Goals Server Services Technologies Dockerization Containerisation Deployment","title":"Home"},{"location":"#welcome-to-area_documentation","text":"This is about the full documentation of AREA project","title":"Welcome to AREA_DOCUMENTATION"},{"location":"#description","text":"The goal of this project is to discover, as a whole, the software platform that you have chosen through the creation of a business application. To do this, AREA is a software suite that functions similar to that of IFTTT and/or Zapier. It is broken into three parts : - An application server to implement all the features listed below (see Features) - A web client to use the application from your browser by querying the application server - A mobile client to use the application from your phone by querying the application server","title":"Description"},{"location":"#features","text":"The application will offer the following funtionalities: - The user registers on the application in order to obtain an account - The registered user then confirms their enrollment on the application before being able to use it - The application then asks the authenticated user to subscribe to Services - Each service offers the following components: * type Action * type REAction - The authenticated user composes AREA by interconnecting an Action to a REAction previously configured - The application triggers AREA automatically thanks to triggers Home Installation Mobile & Web Interface Goals Server Services Technologies Dockerization Containerisation Deployment","title":"Features"},{"location":"About/","text":"Contributing The team that works on this project is made up of 6 members: Omer ADJALLALA : full-stack developper, working as React Web Frontend Master Nicaise GBENOU : Frontend developper, working on web interface with React JS Axel AHO : Frontend developper, working on mobile interface with React native Best HOUNSA : DEVOPS administrator, write documentation, workflow, etc... Kades KOUKPONOU : Cybersec enthousist, working as server Master with NodeJS Aurel AZON : Cybersec enthousist, working on server","title":"About"},{"location":"About/#contributing","text":"The team that works on this project is made up of 6 members: Omer ADJALLALA : full-stack developper, working as React Web Frontend Master Nicaise GBENOU : Frontend developper, working on web interface with React JS Axel AHO : Frontend developper, working on mobile interface with React native Best HOUNSA : DEVOPS administrator, write documentation, workflow, etc... Kades KOUKPONOU : Cybersec enthousist, working as server Master with NodeJS Aurel AZON : Cybersec enthousist, working on server","title":"Contributing"},{"location":"Installation/","text":"Installation First, you need to clone the repository and access on it by your terminal.. git clone git@github.com:EpitechPromo2026/B-DEV-500-COT-5-2-area-aurel.azon.git cd B-DEV-500-COT-5-2-area-aurel.azon Web App cd web docker start systemctl npm -i npm start Mobile app cd mobile npm -i npm start Server cd server docker start systemctl npm -i npm start","title":"Installation"},{"location":"Installation/#installation","text":"First, you need to clone the repository and access on it by your terminal.. git clone git@github.com:EpitechPromo2026/B-DEV-500-COT-5-2-area-aurel.azon.git cd B-DEV-500-COT-5-2-area-aurel.azon","title":"Installation"},{"location":"Installation/#web-app","text":"cd web docker start systemctl npm -i npm start","title":"Web App"},{"location":"Installation/#mobile-app","text":"cd mobile npm -i npm start","title":"Mobile app"},{"location":"Installation/#server","text":"cd server docker start systemctl npm -i npm start","title":"Server"},{"location":"Mobile/","text":"Mobile & Web Interface Tool used for Mobile : React Native Tool used for Web : React JS Login and Register Page Home and Starting Page","title":"Mobile & Web Interface"},{"location":"Mobile/#mobile-web-interface","text":"Tool used for Mobile : React Native Tool used for Web : React JS Login and Register Page Home and Starting Page","title":"Mobile &amp; Web Interface"},{"location":"Objectifs/","text":"AREA's Goals Simplify your digital life. The freedom to create customized automations with ease Automation of tasks (Action-Reaction) between departments Integration of various services (YouTube, Spotify, Twitter...) UI and UX customization Deployment with Docker","title":"Goals"},{"location":"Objectifs/#areas-goals","text":"Simplify your digital life. The freedom to create customized automations with ease Automation of tasks (Action-Reaction) between departments Integration of various services (YouTube, Spotify, Twitter...) UI and UX customization Deployment with Docker","title":"AREA's Goals"},{"location":"Process/","text":"Process","title":"Process & Communication"},{"location":"Process/#process","text":"","title":"Process"},{"location":"Server/","text":"Server Link to the Swagger : http://localhost:8080/api-docs/# on the machine where the Server is. Express Server Component Documentation: Main Application File This documentation describes the main application file of an Express server. The file includes routing for various endpoints, middleware configurations, database interactions, and email sending functionalities. Overview The file creates an Express application and configures it with various routes to handle HTTP requests for registration, login, verification, user retrieval, GitHub events, and user deletion. It also configures a nodemailer transporter for sending emails. Component Structure Dependencies and Initial Setup express: Web framework for Node.js. body-parser: Middleware for parsing request bodies. validator: Used for email validation. dotenv: Loads environment variables from a .env file. cors: Enables Cross-Origin Resource Sharing. nodemailer: Allows sending emails. port: Server port number from environment variables. Middleware Configuration CORS is enabled for all routes. express.json() and express.urlencoded({extended:false}) are used for request body parsing. Nodemailer Transporter Configured with Gmail service and authentication credentials. Utility Functions isEmailValid(email): Validates an email address. generateRandomString(length): Generates a random string of specified length. Routes GET /: A simple route for testing server responsiveness. POST /register: Handles user registration, checks if the email is valid and unique, inserts a new user into the database, and sends a verification email. PUT /verify: Verifies user accounts with a token sent via email. GET /user: Retrieves all user data. POST /git: Placeholder for handling GitHub events. DELETE /delete: Deletes a user by ID. POST /login: Authenticates a user. Additional route for GitHub authentication using a separate router. Server Listening The application listens on the specified port for incoming requests. Usage Ensure all dependencies are installed via npm or yarn. Set up environment variables (e.g., database credentials, server port, email credentials) in a .env file. Run the server using Node.js: bash node path-to-this-file.js Example To start the server, navigate to the directory where this file is located and run: bash node server.js Replace server.js with the actual file name if different. Conclusion This Express application file establishes a backend server with multiple endpoints for user management and integration with external services like email and GitHub. The configuration and routes provided form the core of a backend system that could be part of a larger web application. Mobile React Native Login Component Documentation This documentation details a React Native component named Login. This component is designed for a login screen, providing user interface elements for email and password input, options for social media login, and navigation to other screens upon successful login or registration. Overview The Login component is a functional component that utilizes React's useState hook for managing state. It includes text inputs for email and password, buttons for logging in, and links for social media sign-ins. Component Structure States Email: Stores the user's email address. password: Stores the user's password. Functions checkConnection(mail, pass): This asynchronous function takes email and password as arguments. It makes a POST request to a specified URL (in this case, https://deciding-oyster-probably.ngrok-free.app/login) with the email and password. Depending on the response status, it navigates to the profile screen or shows an alert message. moveToProfile(): Navigates to the ListServices screen. Return (JSX) Text Input for Email: Takes and updates the email state. Text Input for Password: Takes and updates the password state, with secure text entry for privacy. Login Button: On press, calls checkConnection with the current states of Email and Password. Social Media Login Options: Buttons for Google and Facebook login (functionality to be implemented). Navigation to the Register screen. Styles The component uses StyleSheet from react-native for styling. Styles are defined for the container, text inputs, buttons, and other text elements, focusing on layout, color, and typography. Dependencies expo-status-bar: Provides the status bar component. react-native-vector-icons/FontAwesome: Used for social media icons. Usage To use this component in a React Native application: Import the Login component. Include it in your navigation stack or render it as needed. Ensure that the navigation prop is passed if you're using React Navigation for screen transitions. Example jsx import React from 'react'; import Login from './path-to-Login'; // Adjust the import path as needed import { NavigationContainer } from '@react-navigation/native'; import { createStackNavigator } from '@react-navigation/stack'; const Stack = createStackNavigator(); function App() { return ( {/ Other screens /} ); } export default App; WEB React Router Component Documentation: App Component This documentation describes the App component in a React application. This component is responsible for setting up the routing for the application using React Router. It also integrates Google OAuth for the login functionality. Overview The App component is a functional component that uses BrowserRouter and Routes from react-router-dom to define a series of Route components. Each route maps a path in the URL to a specific React component, representing a page in the application. Component Structure Routes /: The root path is linked to the LoadingPage component. /login: Renders the LogInPage component within a GoogleOAuthProvider context. /signup: Mapped to the SignUpPage component. /token: Displays the TokenPage. /home: Links to the HomePage. /applets: Routes to the AppletPage. /areas: Directs to the AreaPage. /profil: Opens the ProfilPage. /spotify: Shows the SpotifyPage. *: A wildcard route that catches all other paths and directs to NotFoundPage. Google OAuth Provider For the login page, the GoogleOAuthProvider component from @react-oauth/google wraps the LogInPage. It requires a clientId which is specific to the application's OAuth credentials set up in Google Cloud Platform. Usage To use this component: Ensure you have react-router-dom and @react-oauth/google installed. Place the App component at the root of your React application. Example Here's how you might use App in the main entry file of a React application: jsx import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; // Adjust the import path as needed ReactDOM.render( , document.getElementById('root') );","title":"Server-Backend"},{"location":"Server/#server","text":"Link to the Swagger : http://localhost:8080/api-docs/# on the machine where the Server is.","title":"Server"},{"location":"Server/#express-server-component-documentation-main-application-file","text":"This documentation describes the main application file of an Express server. The file includes routing for various endpoints, middleware configurations, database interactions, and email sending functionalities.","title":"Express Server Component Documentation: Main Application File"},{"location":"Server/#overview","text":"The file creates an Express application and configures it with various routes to handle HTTP requests for registration, login, verification, user retrieval, GitHub events, and user deletion. It also configures a nodemailer transporter for sending emails.","title":"Overview"},{"location":"Server/#component-structure","text":"","title":"Component Structure"},{"location":"Server/#dependencies-and-initial-setup","text":"express: Web framework for Node.js. body-parser: Middleware for parsing request bodies. validator: Used for email validation. dotenv: Loads environment variables from a .env file. cors: Enables Cross-Origin Resource Sharing. nodemailer: Allows sending emails. port: Server port number from environment variables.","title":"Dependencies and Initial Setup"},{"location":"Server/#middleware-configuration","text":"CORS is enabled for all routes. express.json() and express.urlencoded({extended:false}) are used for request body parsing.","title":"Middleware Configuration"},{"location":"Server/#nodemailer-transporter","text":"Configured with Gmail service and authentication credentials.","title":"Nodemailer Transporter"},{"location":"Server/#utility-functions","text":"isEmailValid(email): Validates an email address. generateRandomString(length): Generates a random string of specified length.","title":"Utility Functions"},{"location":"Server/#routes","text":"GET /: A simple route for testing server responsiveness. POST /register: Handles user registration, checks if the email is valid and unique, inserts a new user into the database, and sends a verification email. PUT /verify: Verifies user accounts with a token sent via email. GET /user: Retrieves all user data. POST /git: Placeholder for handling GitHub events. DELETE /delete: Deletes a user by ID. POST /login: Authenticates a user. Additional route for GitHub authentication using a separate router.","title":"Routes"},{"location":"Server/#server-listening","text":"The application listens on the specified port for incoming requests.","title":"Server Listening"},{"location":"Server/#usage","text":"Ensure all dependencies are installed via npm or yarn. Set up environment variables (e.g., database credentials, server port, email credentials) in a .env file. Run the server using Node.js: bash node path-to-this-file.js","title":"Usage"},{"location":"Server/#example","text":"To start the server, navigate to the directory where this file is located and run: bash node server.js Replace server.js with the actual file name if different.","title":"Example"},{"location":"Server/#conclusion","text":"This Express application file establishes a backend server with multiple endpoints for user management and integration with external services like email and GitHub. The configuration and routes provided form the core of a backend system that could be part of a larger web application.","title":"Conclusion"},{"location":"Server/#mobile","text":"","title":"Mobile"},{"location":"Server/#react-native-login-component-documentation","text":"This documentation details a React Native component named Login. This component is designed for a login screen, providing user interface elements for email and password input, options for social media login, and navigation to other screens upon successful login or registration.","title":"React Native Login Component Documentation"},{"location":"Server/#overview_1","text":"The Login component is a functional component that utilizes React's useState hook for managing state. It includes text inputs for email and password, buttons for logging in, and links for social media sign-ins.","title":"Overview"},{"location":"Server/#component-structure_1","text":"","title":"Component Structure"},{"location":"Server/#states","text":"Email: Stores the user's email address. password: Stores the user's password.","title":"States"},{"location":"Server/#functions","text":"checkConnection(mail, pass): This asynchronous function takes email and password as arguments. It makes a POST request to a specified URL (in this case, https://deciding-oyster-probably.ngrok-free.app/login) with the email and password. Depending on the response status, it navigates to the profile screen or shows an alert message. moveToProfile(): Navigates to the ListServices screen.","title":"Functions"},{"location":"Server/#return-jsx","text":"Text Input for Email: Takes and updates the email state. Text Input for Password: Takes and updates the password state, with secure text entry for privacy. Login Button: On press, calls checkConnection with the current states of Email and Password. Social Media Login Options: Buttons for Google and Facebook login (functionality to be implemented). Navigation to the Register screen.","title":"Return (JSX)"},{"location":"Server/#styles","text":"The component uses StyleSheet from react-native for styling. Styles are defined for the container, text inputs, buttons, and other text elements, focusing on layout, color, and typography.","title":"Styles"},{"location":"Server/#dependencies","text":"expo-status-bar: Provides the status bar component. react-native-vector-icons/FontAwesome: Used for social media icons.","title":"Dependencies"},{"location":"Server/#usage_1","text":"To use this component in a React Native application: Import the Login component. Include it in your navigation stack or render it as needed. Ensure that the navigation prop is passed if you're using React Navigation for screen transitions.","title":"Usage"},{"location":"Server/#example_1","text":"jsx import React from 'react'; import Login from './path-to-Login'; // Adjust the import path as needed import { NavigationContainer } from '@react-navigation/native'; import { createStackNavigator } from '@react-navigation/stack'; const Stack = createStackNavigator(); function App() { return ( {/ Other screens /} ); } export default App;","title":"Example"},{"location":"Server/#web","text":"","title":"WEB"},{"location":"Server/#react-router-component-documentation-app-component","text":"This documentation describes the App component in a React application. This component is responsible for setting up the routing for the application using React Router. It also integrates Google OAuth for the login functionality.","title":"React Router Component Documentation: App Component"},{"location":"Server/#overview_2","text":"The App component is a functional component that uses BrowserRouter and Routes from react-router-dom to define a series of Route components. Each route maps a path in the URL to a specific React component, representing a page in the application.","title":"Overview"},{"location":"Server/#component-structure_2","text":"","title":"Component Structure"},{"location":"Server/#routes_1","text":"/: The root path is linked to the LoadingPage component. /login: Renders the LogInPage component within a GoogleOAuthProvider context. /signup: Mapped to the SignUpPage component. /token: Displays the TokenPage. /home: Links to the HomePage. /applets: Routes to the AppletPage. /areas: Directs to the AreaPage. /profil: Opens the ProfilPage. /spotify: Shows the SpotifyPage. *: A wildcard route that catches all other paths and directs to NotFoundPage.","title":"Routes"},{"location":"Server/#google-oauth-provider","text":"For the login page, the GoogleOAuthProvider component from @react-oauth/google wraps the LogInPage. It requires a clientId which is specific to the application's OAuth credentials set up in Google Cloud Platform.","title":"Google OAuth Provider"},{"location":"Server/#usage_2","text":"To use this component: Ensure you have react-router-dom and @react-oauth/google installed. Place the App component at the root of your React application.","title":"Usage"},{"location":"Server/#example_2","text":"Here's how you might use App in the main entry file of a React application: jsx import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; // Adjust the import path as needed ReactDOM.render( , document.getElementById('root') );","title":"Example"},{"location":"Services/","text":"Services Services that are already integrated with Action-Reactions Documentation: GitHub Issue Notifications via Email This documentation provides a step-by-step guide to set up email notifications for two specific actions on GitHub: when a new issue is created and when an issue is assigned to someone. The notifications will be sent via email. Setting Up Email Notifications for New Issues on GitHub Step 1: Access GitHub Settings Log in to your GitHub account. Navigate to the upper-right corner of the page, click on your profile photo, then click Settings . Step 2: Navigate to Notifications On the settings page, find and click on Notifications in the sidebar. Step 3: Configure Email Notifications Under the Email notification preferences section, ensure your email address is correct. Check the box next to Participating and @mentions to receive notifications for activities you're participating in or mentioned. Step 4: Manage Repository Notifications - Connection on our platform AREA - Get user on the AREA platform - Get References from Users - Find the right Action - Find all reactions according to this actions Step 5: Testing To test, create a new issue in the repository or ask someone to create one. You should receive an email notification. Setting Up Email Notifications for Assigned Issues on GitHub Step 1: Access GitHub Settings Log in to your GitHub account. Click on your profile photo in the upper-right corner and select Settings . Step 2: Navigate to Notifications From the settings page, click on Notifications . Step 3: Configure Email Notifications Ensure your email address is correctly listed under Email notification preferences . Make sure the box next to Participating and @mentions is checked. Step 4: Set Up Notifications for Assigned Issues Go to the repository you are interested in. Connection on our platform AREA Get user on the AREA platform Get References from Users Find the right Action Find all reactions according to this actions Step 5: Activate Issue Assignments For this step, you need to ensure that you are part of a team or have collaborators who can assign issues to you. Once an issue is assigned to you, GitHub will automatically send a notification. Step 6: Testing Have a collaborator assign an issue to you or, if you have another GitHub account, assign an issue to your primary account. You should receive an email notification about the assignment. Our Stack (MyRN) MySQL : For the database React & React Native : For the interface NodeJS : For the backend","title":"Services"},{"location":"Services/#services","text":"","title":"Services"},{"location":"Services/#services-that-are-already-integrated-with-action-reactions","text":"","title":"Services that are already integrated with Action-Reactions"},{"location":"Services/#documentation-github-issue-notifications-via-email","text":"This documentation provides a step-by-step guide to set up email notifications for two specific actions on GitHub: when a new issue is created and when an issue is assigned to someone. The notifications will be sent via email.","title":"Documentation: GitHub Issue Notifications via Email"},{"location":"Services/#setting-up-email-notifications-for-new-issues-on-github","text":"","title":"Setting Up Email Notifications for New Issues on GitHub"},{"location":"Services/#step-1-access-github-settings","text":"Log in to your GitHub account. Navigate to the upper-right corner of the page, click on your profile photo, then click Settings .","title":"Step 1: Access GitHub Settings"},{"location":"Services/#step-2-navigate-to-notifications","text":"On the settings page, find and click on Notifications in the sidebar.","title":"Step 2: Navigate to Notifications"},{"location":"Services/#step-3-configure-email-notifications","text":"Under the Email notification preferences section, ensure your email address is correct. Check the box next to Participating and @mentions to receive notifications for activities you're participating in or mentioned.","title":"Step 3: Configure Email Notifications"},{"location":"Services/#step-4-manage-repository-notifications","text":"- Connection on our platform AREA - Get user on the AREA platform - Get References from Users - Find the right Action - Find all reactions according to this actions","title":"Step 4: Manage Repository Notifications"},{"location":"Services/#step-5-testing","text":"To test, create a new issue in the repository or ask someone to create one. You should receive an email notification.","title":"Step 5: Testing"},{"location":"Services/#setting-up-email-notifications-for-assigned-issues-on-github","text":"","title":"Setting Up Email Notifications for Assigned Issues on GitHub"},{"location":"Services/#step-1-access-github-settings_1","text":"Log in to your GitHub account. Click on your profile photo in the upper-right corner and select Settings .","title":"Step 1: Access GitHub Settings"},{"location":"Services/#step-2-navigate-to-notifications_1","text":"From the settings page, click on Notifications .","title":"Step 2: Navigate to Notifications"},{"location":"Services/#step-3-configure-email-notifications_1","text":"Ensure your email address is correctly listed under Email notification preferences . Make sure the box next to Participating and @mentions is checked.","title":"Step 3: Configure Email Notifications"},{"location":"Services/#step-4-set-up-notifications-for-assigned-issues","text":"Go to the repository you are interested in. Connection on our platform AREA Get user on the AREA platform Get References from Users Find the right Action Find all reactions according to this actions","title":"Step 4: Set Up Notifications for Assigned Issues"},{"location":"Services/#step-5-activate-issue-assignments","text":"For this step, you need to ensure that you are part of a team or have collaborators who can assign issues to you. Once an issue is assigned to you, GitHub will automatically send a notification.","title":"Step 5: Activate Issue Assignments"},{"location":"Services/#step-6-testing","text":"Have a collaborator assign an issue to you or, if you have another GitHub account, assign an issue to your primary account. You should receive an email notification about the assignment.","title":"Step 6: Testing"},{"location":"Services/#our-stack-myrn","text":"MySQL : For the database React & React Native : For the interface NodeJS : For the backend","title":"Our Stack (MyRN)"},{"location":"Web/","text":"WEB Tool used : React JS Login Page Services Pages Github Service Page","title":"WEB"},{"location":"Web/#web","text":"Tool used : React JS Login Page Services Pages Github Service Page","title":"WEB"},{"location":"containerization/","text":"Documentation for Docker Compose File This section explains the Docker Compose file, which is used to define and run multi-container Docker applications. Here, we have a setup with four services: mysql , myserver , myapp , and myweb . Below is a detailed explanation of each part and the commands to test and potentially install necessary components. Services 1. MySQL Service Image: The service uses the official MySQL image version 8.0. Command: It's configured to use mysql_native_password for authentication. Restart Policy: Set to always restart the container if it stops. Ports: Maps port 3306 of the container to port 3306 on the host. Exposed Ports: Exposes port 3306 inside the Docker network. Environment Variables: MYSQL_ROOT_PASSWORD : Sets the root password to 'gaius155'. MYSQL_DATABASE : Creates a database named 'area'. MYSQL_USER : Sets the default user to 'root'. But it's considered as bad habits to let alls creds in clear text inside any kind of config files, so you should add them in .env to have safe practice Testing MySQL Service To test the MySQL service, you would typically connect to the MySQL server using a MySQL client. mysql -h 127.0.0.1 -u root -pgaius155 2. MyServer Service Build Context: Specifies the build context as ./server with a Dockerfile. Dependency: Depends on the MySQL service. Volumes: Maps node_modules folder. Maps the local ./server directory to /app in the container. Ports: Maps port 8080 of the container to port 8080 on the host. Exposed Ports: Exposes port 8080 inside the Docker network. Testing MyServer Service Testing this service involves making requests to the server, assuming it's a web server running on port 8080. curl http://localhost:8080 3. MyApp Service Build Context: Uses ./mobile as the build context with a Dockerfile. Dependency: Depends on the MyServer service. Volumes: Maps node_modules folder. Maps the local ./mobile directory to /app in the container. Maps a volume named apk to /usr/src/app/apk/ with read-write access. Exposed Ports: None specifically mentioned. Testing MyApp Service Testing would depend on the nature of the application. If it\u2019s a web app, accessing it via a browser might be appropriate. 4. MyWeb Service Build Context: Uses ./web as the build context with a Dockerfile. Ports: Maps port 8081 of the container to port 8081 on the host. Exposed Ports: Exposes port 8081 inside the Docker network. Dependency: Depends on the MyServer service. Volumes: Maps node_modules folder. Maps the local ./web directory to /app in the container. Testing MyWeb Service Similar to MyServer, you can test this by making HTTP requests: curl http://localhost:8081 Volumes apk: A named volume for storing APK files, used by the myapp service. Potential Installations Before running this Docker Compose file, ensure that you have the following installed: Docker: To run containers. Docker Compose: To manage multi-container applications. Running the Docker Compose File To start the services defined in this file, use the following command: docker-compose up This command builds, (re)creates, starts, and attaches to containers for a service. To stop and remove the containers, networks, and volumes, use: docker-compose down This Docker Compose file sets up a robust environment with a MySQL database, a server, a mobile application, and a web interface, each running in its own container, interconnected and configured to work together.","title":"Containerization"},{"location":"containerization/#documentation-for-docker-compose-file","text":"This section explains the Docker Compose file, which is used to define and run multi-container Docker applications. Here, we have a setup with four services: mysql , myserver , myapp , and myweb . Below is a detailed explanation of each part and the commands to test and potentially install necessary components.","title":"Documentation for Docker Compose File"},{"location":"containerization/#services","text":"","title":"Services"},{"location":"containerization/#1-mysql-service","text":"Image: The service uses the official MySQL image version 8.0. Command: It's configured to use mysql_native_password for authentication. Restart Policy: Set to always restart the container if it stops. Ports: Maps port 3306 of the container to port 3306 on the host. Exposed Ports: Exposes port 3306 inside the Docker network. Environment Variables: MYSQL_ROOT_PASSWORD : Sets the root password to 'gaius155'. MYSQL_DATABASE : Creates a database named 'area'. MYSQL_USER : Sets the default user to 'root'. But it's considered as bad habits to let alls creds in clear text inside any kind of config files, so you should add them in .env to have safe practice","title":"1. MySQL Service"},{"location":"containerization/#testing-mysql-service","text":"To test the MySQL service, you would typically connect to the MySQL server using a MySQL client. mysql -h 127.0.0.1 -u root -pgaius155","title":"Testing MySQL Service"},{"location":"containerization/#2-myserver-service","text":"Build Context: Specifies the build context as ./server with a Dockerfile. Dependency: Depends on the MySQL service. Volumes: Maps node_modules folder. Maps the local ./server directory to /app in the container. Ports: Maps port 8080 of the container to port 8080 on the host. Exposed Ports: Exposes port 8080 inside the Docker network.","title":"2. MyServer Service"},{"location":"containerization/#testing-myserver-service","text":"Testing this service involves making requests to the server, assuming it's a web server running on port 8080. curl http://localhost:8080","title":"Testing MyServer Service"},{"location":"containerization/#3-myapp-service","text":"Build Context: Uses ./mobile as the build context with a Dockerfile. Dependency: Depends on the MyServer service. Volumes: Maps node_modules folder. Maps the local ./mobile directory to /app in the container. Maps a volume named apk to /usr/src/app/apk/ with read-write access. Exposed Ports: None specifically mentioned.","title":"3. MyApp Service"},{"location":"containerization/#testing-myapp-service","text":"Testing would depend on the nature of the application. If it\u2019s a web app, accessing it via a browser might be appropriate.","title":"Testing MyApp Service"},{"location":"containerization/#4-myweb-service","text":"Build Context: Uses ./web as the build context with a Dockerfile. Ports: Maps port 8081 of the container to port 8081 on the host. Exposed Ports: Exposes port 8081 inside the Docker network. Dependency: Depends on the MyServer service. Volumes: Maps node_modules folder. Maps the local ./web directory to /app in the container.","title":"4. MyWeb Service"},{"location":"containerization/#testing-myweb-service","text":"Similar to MyServer, you can test this by making HTTP requests: curl http://localhost:8081","title":"Testing MyWeb Service"},{"location":"containerization/#volumes","text":"apk: A named volume for storing APK files, used by the myapp service.","title":"Volumes"},{"location":"containerization/#potential-installations","text":"Before running this Docker Compose file, ensure that you have the following installed: Docker: To run containers. Docker Compose: To manage multi-container applications.","title":"Potential Installations"},{"location":"containerization/#running-the-docker-compose-file","text":"To start the services defined in this file, use the following command: docker-compose up This command builds, (re)creates, starts, and attaches to containers for a service. To stop and remove the containers, networks, and volumes, use: docker-compose down This Docker Compose file sets up a robust environment with a MySQL database, a server, a mobile application, and a web interface, each running in its own container, interconnected and configured to work together.","title":"Running the Docker Compose File"},{"location":"deployment/","text":"Documentation for custom Deployment : Docker Container Management This Bash script provides a convenient way to manage Docker containers through various command-line options. It's designed to simplify common Docker tasks such as deploying, stopping, and removing containers. Below is a detailed explanation of each part of the script and the associated commands. Script Overview The script starts by defining color codes for different types of output messages. It then declares several functions, each corresponding to a specific Docker management task. The script ends with a while loop to parse command-line arguments and execute the appropriate functions. Color Definitions Colors: Various colors like GREEN, BLUE, PURPLE, WHITE, RED, ORANGE, and YELLOW are defined for formatting the output. Functions 1. delete_containers Purpose: Removes all Docker containers. Command: docker rm $(docker ps -aq) Output: Red color text indicating the deletion of containers. 2. deploy_containers Purpose: Deploys all Docker containers using Docker Compose. Command: docker-compose up -d Output: Green color text indicating the deployment of containers. 3. stop_containers Purpose: Stops all running Docker containers. Command: docker stop $(docker ps -aq) Output: Blue color text indicating the stopping of containers. 4. prune_containers Purpose: Stops and removes all Docker containers. Command: Combines the commands from stop_containers and delete_containers . Output: Purple color text indicating the pruning of containers. 5. shell_containers Purpose: Opens a Bash shell in a specified container. Command: docker exec -it $1 /bin/bash Output: Orange color text indicating the spawning of a shell in a container. 6. list_containers Purpose: Lists all Docker containers. Command: docker ps -a Output: Yellow color text showing all available containers. 7. show_help Purpose: Displays usage instructions for the script. Output: Descriptions of all available script options. Command-Line Options --delete : Executes delete_containers . --deploy : Executes deploy_containers . --stop : Executes stop_containers . --prune : Executes prune_containers . --shell : Executes shell_containers with a specified container. --list : Executes list_containers . --help : Displays help information with show_help . Using the Script To use the script, you can invoke it with one of the defined options. For example: ./script.sh --list This command will list all running Docker containers. Prerequisites Before using this script, ensure that Docker and Docker Compose are installed on your system. Conclusion This script is a handy tool for managing Docker containers, offering a simplified interface for common Docker commands. It enhances user experience by providing easy-to-understand, color-coded outputs and a straightforward command-line interface.","title":"Deployment"},{"location":"deployment/#documentation-for-custom-deployment-docker-container-management","text":"This Bash script provides a convenient way to manage Docker containers through various command-line options. It's designed to simplify common Docker tasks such as deploying, stopping, and removing containers. Below is a detailed explanation of each part of the script and the associated commands.","title":"Documentation for custom Deployment : Docker Container Management"},{"location":"deployment/#script-overview","text":"The script starts by defining color codes for different types of output messages. It then declares several functions, each corresponding to a specific Docker management task. The script ends with a while loop to parse command-line arguments and execute the appropriate functions.","title":"Script Overview"},{"location":"deployment/#color-definitions","text":"Colors: Various colors like GREEN, BLUE, PURPLE, WHITE, RED, ORANGE, and YELLOW are defined for formatting the output.","title":"Color Definitions"},{"location":"deployment/#functions","text":"","title":"Functions"},{"location":"deployment/#1-delete_containers","text":"Purpose: Removes all Docker containers. Command: docker rm $(docker ps -aq) Output: Red color text indicating the deletion of containers.","title":"1. delete_containers"},{"location":"deployment/#2-deploy_containers","text":"Purpose: Deploys all Docker containers using Docker Compose. Command: docker-compose up -d Output: Green color text indicating the deployment of containers.","title":"2. deploy_containers"},{"location":"deployment/#3-stop_containers","text":"Purpose: Stops all running Docker containers. Command: docker stop $(docker ps -aq) Output: Blue color text indicating the stopping of containers.","title":"3. stop_containers"},{"location":"deployment/#4-prune_containers","text":"Purpose: Stops and removes all Docker containers. Command: Combines the commands from stop_containers and delete_containers . Output: Purple color text indicating the pruning of containers.","title":"4. prune_containers"},{"location":"deployment/#5-shell_containers","text":"Purpose: Opens a Bash shell in a specified container. Command: docker exec -it $1 /bin/bash Output: Orange color text indicating the spawning of a shell in a container.","title":"5. shell_containers"},{"location":"deployment/#6-list_containers","text":"Purpose: Lists all Docker containers. Command: docker ps -a Output: Yellow color text showing all available containers.","title":"6. list_containers"},{"location":"deployment/#7-show_help","text":"Purpose: Displays usage instructions for the script. Output: Descriptions of all available script options.","title":"7. show_help"},{"location":"deployment/#command-line-options","text":"--delete : Executes delete_containers . --deploy : Executes deploy_containers . --stop : Executes stop_containers . --prune : Executes prune_containers . --shell : Executes shell_containers with a specified container. --list : Executes list_containers . --help : Displays help information with show_help .","title":"Command-Line Options"},{"location":"deployment/#using-the-script","text":"To use the script, you can invoke it with one of the defined options. For example: ./script.sh --list This command will list all running Docker containers.","title":"Using the Script"},{"location":"deployment/#prerequisites","text":"Before using this script, ensure that Docker and Docker Compose are installed on your system.","title":"Prerequisites"},{"location":"deployment/#conclusion","text":"This script is a handy tool for managing Docker containers, offering a simplified interface for common Docker commands. It enhances user experience by providing easy-to-understand, color-coded outputs and a straightforward command-line interface.","title":"Conclusion"},{"location":"dockerisation/","text":"Dockerisation: Understanding Dockerfile Configurations This documentation explains the Dockerfile configurations for our three components of AREA : mobile , web , and server . Each Dockerfile is set up to build a Docker image for its respective component. Below is a detailed explanation of each Dockerfile. 1. Mobile Dockerfile Located in mobile/Dockerfile , this file defines the setup for a mobile application environment. Configuration Base Image: node:20.10.0 . Uses Node.js version 20.10.0. User: root . Sets the user to root. Shell: Specifies the Bash shell for running commands. Working Directory: /app . Sets the working directory inside the container. Copy Command: Copies everything from the current directory into /app/ inside the container. Expose: Exposes port 8081. Run Commands: Lists contents of the pages directory. Installs dependencies with npm install . Installs nodemon globally. CMD: Sets the default command to npm start . Building the Image To build the Docker image for the mobile app, run: docker build -t mobile-app ./mobile 2. Web Dockerfile Located in web/Dockerfile , this file sets up the environment for a web application. Configuration Base Image: node:20.10.0 . User: root . Shell: Uses Bash shell. Working Directory: /app . Copy Command: Copies files into /app/ . Expose: Exposes port 8081. Run Commands: Lists contents of the src directory. Installs dependencies with yarn . CMD: Runs npm start to start the application. Building the Image To build the Docker image for the web app, use: docker build -t web-app ./web 3. Server Dockerfile Located in server/Dockerfile , this Dockerfile is for setting up the server environment. Configuration Base Image: node:20.10.0 . User: root . Shell: Bash shell. Working Directory: /app . Copy Commands: Copies all files into /app/ . Copies .env file. Expose: Exposes port 8080. Run Commands: Lists contents of the src directory. Installs dependencies. Installs nodemon globally. CMD: Uses nodemon to start the server with src/index.js . Building the Image To create the Docker image for the server, execute: docker build -t server-app ./server Conclusion Each Dockerfile is tailored to the specific needs of the mobile, web, and server components of an application. They provide a consistent and reproducible environment for development and deployment. By isolating each part of the application in its own container, Docker helps us in managing dependencies and ensuring that the application runs the same way in any environment.","title":"Dockerization"},{"location":"dockerisation/#dockerisation-understanding-dockerfile-configurations","text":"This documentation explains the Dockerfile configurations for our three components of AREA : mobile , web , and server . Each Dockerfile is set up to build a Docker image for its respective component. Below is a detailed explanation of each Dockerfile.","title":"Dockerisation: Understanding Dockerfile Configurations"},{"location":"dockerisation/#1-mobile-dockerfile","text":"Located in mobile/Dockerfile , this file defines the setup for a mobile application environment.","title":"1. Mobile Dockerfile"},{"location":"dockerisation/#configuration","text":"Base Image: node:20.10.0 . Uses Node.js version 20.10.0. User: root . Sets the user to root. Shell: Specifies the Bash shell for running commands. Working Directory: /app . Sets the working directory inside the container. Copy Command: Copies everything from the current directory into /app/ inside the container. Expose: Exposes port 8081. Run Commands: Lists contents of the pages directory. Installs dependencies with npm install . Installs nodemon globally. CMD: Sets the default command to npm start .","title":"Configuration"},{"location":"dockerisation/#building-the-image","text":"To build the Docker image for the mobile app, run: docker build -t mobile-app ./mobile","title":"Building the Image"},{"location":"dockerisation/#2-web-dockerfile","text":"Located in web/Dockerfile , this file sets up the environment for a web application.","title":"2. Web Dockerfile"},{"location":"dockerisation/#configuration_1","text":"Base Image: node:20.10.0 . User: root . Shell: Uses Bash shell. Working Directory: /app . Copy Command: Copies files into /app/ . Expose: Exposes port 8081. Run Commands: Lists contents of the src directory. Installs dependencies with yarn . CMD: Runs npm start to start the application.","title":"Configuration"},{"location":"dockerisation/#building-the-image_1","text":"To build the Docker image for the web app, use: docker build -t web-app ./web","title":"Building the Image"},{"location":"dockerisation/#3-server-dockerfile","text":"Located in server/Dockerfile , this Dockerfile is for setting up the server environment.","title":"3. Server Dockerfile"},{"location":"dockerisation/#configuration_2","text":"Base Image: node:20.10.0 . User: root . Shell: Bash shell. Working Directory: /app . Copy Commands: Copies all files into /app/ . Copies .env file. Expose: Exposes port 8080. Run Commands: Lists contents of the src directory. Installs dependencies. Installs nodemon globally. CMD: Uses nodemon to start the server with src/index.js .","title":"Configuration"},{"location":"dockerisation/#building-the-image_2","text":"To create the Docker image for the server, execute: docker build -t server-app ./server","title":"Building the Image"},{"location":"dockerisation/#conclusion","text":"Each Dockerfile is tailored to the specific needs of the mobile, web, and server components of an application. They provide a consistent and reproducible environment for development and deployment. By isolating each part of the application in its own container, Docker helps us in managing dependencies and ensuring that the application runs the same way in any environment.","title":"Conclusion"},{"location":"technologies/","text":"Detailed Guide: Installation, Building, and Running Technologies This guide covers the installation, building, and running processes for the technologies and tools used in our AREA's project. These include the setup for MySQL, Node.js with Express, React with Material UI, React Native, and Docker for deployment. Technology Setup 1. MySQL Installation Windows: Download the installer from the MySQL website and follow the setup wizard. Linux: Use package managers like apt or yum . bash sudo apt-get update sudo apt-get install mysql-server macOS: Use Homebrew: bash brew install mysql Building and Running Start MySQL Service: Windows: Use the MySQL Notifier tool or services app. Linux/macOS: sudo service mysql start Access MySQL: bash mysql -u root -p 2. Node.js with Installation Download and install Node.js from Node.js website . Verify installation: bash node --version npm --version Building and Running a Basic Server Create a new directory and initialize a Node.js project: bash mkdir myapp cd myapp npm init -y Install Express: bash npm install express Create an index.js file with a simple server: ```javascript const express = require('express'); const app = express(); app.get('/', (req, res) => { res.send('Hello World!'); }); app.listen(3000, () => { console.log('Server is running on port 3000'); }); - **Run the server:** bash node index.js ``` 3. React Installation Ensure Node.js is installed. Create a new React app: bash npx create-react-app my-react-app cd my-react-app Install Material-UI: bash npm install @mui/material @emotion/react @emotion/styled Building and Running Modify App.js to include Material UI components. Start the React app: bash npm start 4. React Native Installation Install Node.js, then install React Native CLI: bash npm install -g react-native-cli Install Android Studio for Android development or Xcode for iOS development. Building and Running a Basic App Initialize a new React Native project: bash react-native init MyReactNativeApp Run the app: For Android: react-native run-android For iOS: react-native run-ios 5. Docker Installation Download Docker Desktop from the Docker website for Windows or Mac. For Linux, install using the package manager: bash sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io Building and Running a Docker Container Create a Dockerfile in your project directory. Build the Docker image: bash docker build -t myapp . Run the container: bash docker run -p 4000:80 myapp Tools Trello A web-based project management application. Sign up and create boards for task management at Trello\u2019s website . Canva An online design and publishing tool. Start designing at Canva\u2019s website . Figma A web-based UI design and prototyping tool. Access Figma at Figma\u2019s website . GitHub A platform for version control and collaboration. Create an account and start managing code repositories at GitHub\u2019s website .","title":"Technologies"},{"location":"technologies/#detailed-guide-installation-building-and-running-technologies","text":"This guide covers the installation, building, and running processes for the technologies and tools used in our AREA's project. These include the setup for MySQL, Node.js with Express, React with Material UI, React Native, and Docker for deployment.","title":"Detailed Guide: Installation, Building, and Running Technologies"},{"location":"technologies/#technology-setup","text":"","title":"Technology Setup"},{"location":"technologies/#1-mysql","text":"","title":"1. MySQL"},{"location":"technologies/#installation","text":"Windows: Download the installer from the MySQL website and follow the setup wizard. Linux: Use package managers like apt or yum . bash sudo apt-get update sudo apt-get install mysql-server macOS: Use Homebrew: bash brew install mysql","title":"Installation"},{"location":"technologies/#building-and-running","text":"Start MySQL Service: Windows: Use the MySQL Notifier tool or services app. Linux/macOS: sudo service mysql start Access MySQL: bash mysql -u root -p","title":"Building and Running"},{"location":"technologies/#2-nodejs-with","text":"","title":"2. Node.js with"},{"location":"technologies/#installation_1","text":"Download and install Node.js from Node.js website . Verify installation: bash node --version npm --version","title":"Installation"},{"location":"technologies/#building-and-running-a-basic-server","text":"Create a new directory and initialize a Node.js project: bash mkdir myapp cd myapp npm init -y Install Express: bash npm install express Create an index.js file with a simple server: ```javascript const express = require('express'); const app = express(); app.get('/', (req, res) => { res.send('Hello World!'); }); app.listen(3000, () => { console.log('Server is running on port 3000'); }); - **Run the server:** bash node index.js ```","title":"Building and Running a Basic Server"},{"location":"technologies/#3-react","text":"","title":"3. React"},{"location":"technologies/#installation_2","text":"Ensure Node.js is installed. Create a new React app: bash npx create-react-app my-react-app cd my-react-app Install Material-UI: bash npm install @mui/material @emotion/react @emotion/styled","title":"Installation"},{"location":"technologies/#building-and-running_1","text":"Modify App.js to include Material UI components. Start the React app: bash npm start","title":"Building and Running"},{"location":"technologies/#4-react-native","text":"","title":"4. React Native"},{"location":"technologies/#installation_3","text":"Install Node.js, then install React Native CLI: bash npm install -g react-native-cli Install Android Studio for Android development or Xcode for iOS development.","title":"Installation"},{"location":"technologies/#building-and-running-a-basic-app","text":"Initialize a new React Native project: bash react-native init MyReactNativeApp Run the app: For Android: react-native run-android For iOS: react-native run-ios","title":"Building and Running a Basic App"},{"location":"technologies/#5-docker","text":"","title":"5. Docker"},{"location":"technologies/#installation_4","text":"Download Docker Desktop from the Docker website for Windows or Mac. For Linux, install using the package manager: bash sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io","title":"Installation"},{"location":"technologies/#building-and-running-a-docker-container","text":"Create a Dockerfile in your project directory. Build the Docker image: bash docker build -t myapp . Run the container: bash docker run -p 4000:80 myapp","title":"Building and Running a Docker Container"},{"location":"technologies/#tools","text":"","title":"Tools"},{"location":"technologies/#trello","text":"A web-based project management application. Sign up and create boards for task management at Trello\u2019s website .","title":"Trello"},{"location":"technologies/#canva","text":"An online design and publishing tool. Start designing at Canva\u2019s website .","title":"Canva"},{"location":"technologies/#figma","text":"A web-based UI design and prototyping tool. Access Figma at Figma\u2019s website .","title":"Figma"},{"location":"technologies/#github","text":"A platform for version control and collaboration. Create an account and start managing code repositories at GitHub\u2019s website .","title":"GitHub"}]}